@namespace BlazorApp.Components
@using Confluent.Kafka
@using System.Text.Json
@inject KafkaSettings KafkaSettings
@inject State State

<div class="@(IsConsuming ? "consumer" : "consumer-inactive")">
    <h3>Consumer</h3>
    <div>partitions:
        @foreach (var partition in Partitions)
        {
            @partition
        }
    </div>
    <button @onclick="Consume" disabled="@(IsConsuming || !State.IsBrokerReady || IsLoading)">Consume</button>
    <button @onclick="Close" disabled="@(!IsConsuming)">Close</button>
    <div>@Log</div>
</div>

@code {
    public bool IsConsuming { get; set; } = false;
    public bool IsLoading { get; set; } = false;

    public IEnumerable<int> Partitions { get; set; } = new int[0];

    public string Log { get; set; } = string.Empty;

    private CancellationTokenSource? cancellationTokenSource;

    private IConsumer<Ignore, string>? consumer;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        State.StateChanged += OnStateChanged;
    }

    private void OnStateChanged(object? sender, EventArgs args)
    {
        InvokeAsync(StateHasChanged);
    }

    private async Task Consume()
    {
        IsLoading = true;

        cancellationTokenSource = new CancellationTokenSource();

        var config = new ConsumerConfig
        {
            BootstrapServers = KafkaSettings.BootstrapServers,
            SaslUsername = KafkaSettings.SaslUsername,
            SaslPassword = KafkaSettings.SaslPassword,
            SecurityProtocol = SecurityProtocol.SaslSsl,
            SaslMechanism = SaslMechanism.Plain,
            GroupId = "temporary",
            AutoOffsetReset = AutoOffsetReset.Latest,
            EnableAutoCommit = false,
        };

        using (consumer = new ConsumerBuilder<Ignore, string>(config)
        .SetPartitionsAssignedHandler((consumer, partitions) =>
        {
            Partitions = partitions.Select(partition => partition.Partition.Value);
            IsLoading = false;
            IsConsuming = true;
            InvokeAsync(StateHasChanged);
        })
        .SetPartitionsRevokedHandler((consumer, partitions) =>
        {
            IsConsuming = false;
        })
        .Build())
        {
            consumer.Subscribe(State.SingleTopic);

            await Task.Run(() =>
            {
                while(!cancellationTokenSource.Token.IsCancellationRequested)
                {
                    try
                    {
                        Log = "consuming...";
                        InvokeAsync(StateHasChanged);
                        var consumeResult = consumer.Consume(cancellationTokenSource.Token);
                        var consumeMessage = JsonSerializer.Deserialize<Model.Message>(consumeResult.Message.Value);
                        Log = "handling...";
                        InvokeAsync(StateHasChanged);
                        cancellationTokenSource.Token.WaitHandle.WaitOne(TimeSpan.FromSeconds(3));
                        Log = "handled";

                        if (cancellationTokenSource.Token.IsCancellationRequested)
                        {
                            throw new OperationCanceledException();
                        }

                        consumer.Commit(consumeResult);
                        State.Commit(consumeResult.Partition.Value, consumeMessage.Id, "temporary");
                        Log = "committed";
                        InvokeAsync(StateHasChanged);
                    }
                    catch (OperationCanceledException)
                    {
                        Log = "OperationCanceledException";
                        InvokeAsync(StateHasChanged);
                    }
                }

                consumer.Close();
            });
        };
    }

    private void Close()
    {
        cancellationTokenSource?.Cancel();
    }
}