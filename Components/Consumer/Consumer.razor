@namespace BlazorApp.Components
@using Confluent.Kafka
@using System.Text.Json
@inject KafkaSettings KafkaSettings
@inject State State

<div class="consumer">
    <h3>Consumer</h3>
    <TopicSelector @bind-Topic="Topic" />
    <div>partitions:
        @foreach (var partition in Partitions)
        {
            @partition
        }
    </div>
    <button @onclick="Consume">Consume</button>
    <button @onclick="Close">Close</button>
    <div>@Log</div>
</div>

@code {
    public string? Topic { get; set; }

    public IEnumerable<int> Partitions { get; set; } = new int[0];

    public string Log { get; set; } = string.Empty;

    private CancellationTokenSource? cancellationTokenSource;

    private IConsumer<Ignore, string>? consumer;

    private async void Consume()
    {
        cancellationTokenSource = new CancellationTokenSource();

        var config = new ConsumerConfig
        {
            BootstrapServers = KafkaSettings.BootstrapServers,
            SaslUsername = KafkaSettings.SaslUsername,
            SaslPassword = KafkaSettings.SaslPassword,
            SecurityProtocol = SecurityProtocol.SaslSsl,
            SaslMechanism = SaslMechanism.Plain,
            GroupId = "temporary",
            AutoOffsetReset = AutoOffsetReset.Latest,
            EnableAutoCommit = false,
        };

        using (consumer = new ConsumerBuilder<Ignore, string>(config)
        .SetPartitionsAssignedHandler((consumer, partitions) =>
        {
            Partitions = partitions.Select(partition => partition.Partition.Value);
            InvokeAsync(StateHasChanged);
        })
        .SetPartitionsRevokedHandler((consumer, partitions) =>
        {
        })
        .Build())
        {
            consumer.Subscribe(Topic);

            await Task.Run(() =>
            {
                while(!cancellationTokenSource.Token.IsCancellationRequested)
                {
                    try
                    {
                        Log = "consuming...";
                        InvokeAsync(StateHasChanged);
                        var consumeResult = consumer.Consume(cancellationTokenSource.Token);
                        var consumeMessage = JsonSerializer.Deserialize<Model.Message>(consumeResult.Message.Value);
                        Log = "handling...";
                        InvokeAsync(StateHasChanged);
                        cancellationTokenSource.Token.WaitHandle.WaitOne(TimeSpan.FromSeconds(3));
                        Log = "handled";

                        if (cancellationTokenSource.Token.IsCancellationRequested)
                        {
                            throw new OperationCanceledException();
                        }

                        consumer.Commit(consumeResult);
                        Log = "committed";
                        InvokeAsync(StateHasChanged);
                    }
                    catch (OperationCanceledException)
                    {
                        Log = "OperationCanceledException";
                        InvokeAsync(StateHasChanged);
                    }
                }

                consumer.Close();
            });
        };
    }

    private void Close()
    {
        cancellationTokenSource?.Cancel();
    }
}